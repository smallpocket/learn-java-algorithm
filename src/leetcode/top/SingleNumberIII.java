package leetcode.top;

/**
 * 给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。
 * <p>
 * 示例 :
 * 输入: [1,2,1,3,2,5]
 * 输出: [3,5]
 * <p>
 * 注意：
 * 结果输出的顺序并不重要，对于上面的例子， [5, 3] 也是正确答案。
 * 你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？
 *
 * @author Heper
 * @title 只出现一次的数字 III
 * @date 2019/2/18 16:49
 */
public class SingleNumberIII {
    /**
     * 如果能够把原数组分为两个子数组。在每个子数组中，包含一个只出现一次的数字，而其它数字都出现两次。
     * 如果能够这样拆分原数组，按照前面的办法就是分别求出这两个只出现一次的数字了。
     * 我们还是从头到尾依次异或数组中的每一个数字，那么最终得到的结果就是两个只出现一次的数字的异或结果。
     * 因为其它数字都出现了两次，在异或中全部抵消掉了。由于这两个数字肯定不一样，那么这个异或结果肯定不为0
     * ，也就是说在这个结果数字的二进制表示中至少就有一位为1 。我们在结果数字中找到第一个为1 的位的位置，
     * 记为第N 位。现在我们以第N 位是不是1 为标准把原数组中的数字分成两个子数组，第一个子数组中每个数字
     * 的第N 位都为1 ，而第二个子数组的每个数字的第N 位都为0 。
     * 现在我们已经把原数组分成了两个子数组，每个子数组都包含一个只出现一次的数字，而其它数字都出现了两
     * 次。因此到此为止，所有的问题我们都已经解决。
     *
     * @param nums
     * @return
     */
    public int[] singleNumber(int[] nums) {
        if (nums == null || nums.length == 0) {
            return null;
        }
        int result = 0;
        for (int i : nums) {
            result ^= i;
        }
        //找到result的不为0的第一个字节
        //如何找呢
        int pos = 1;
        while ((result & 1) == 0) {
            result = result >> 1;
            //记录1出现的位置
            pos = pos << 1;
        }
        int[] res = new int[2];
        for (int i : nums) {
            //依据该位置上是否为1将数组拆分为两部分
            if ((i & pos) == 0) {
                res[0] ^= i;
            } else {
                res[1] ^= i;
            }
        }
        return res;
    }
}
